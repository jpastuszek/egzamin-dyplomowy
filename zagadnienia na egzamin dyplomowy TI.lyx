#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language polish
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\headheight 1cm
\headsep 1cm
\footskip 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Omówić pojęcie informatyki i jej działy.
 
\end_layout

\begin_layout Standard
Informatyka – dyscyplina nauki zaliczana do nauk ścisłych oraz techniki
 zajmująca się przetwarzaniem informacji, w tym również technologiami przetwarza
nia informacji oraz technologiami wytwarzania systemów przetwarzających
 informację.
 Początkowo stanowiła część matematyki, później rozwinęła się do odrębnej
 dyscypliny – pozostaje jednak nadal w ścisłej relacji z matematyką, która
 dostarcza informatyce podstaw teoretycznych.
 
\end_layout

\begin_layout Standard
Bardziej znane i popularne działy informatyki to przede wszystkim:
\end_layout

\begin_layout Itemize
administracja sieciowa – zarządzanie siecią komputerową;
\end_layout

\begin_layout Itemize
administracja systemem – zarządzanie systemem informatycznym;
\end_layout

\begin_layout Itemize
algorytmika – tworzenie i analizowanie algorytmów.
 Podstawowa, najstarsza dyscyplina informatyki;
\end_layout

\begin_layout Itemize
architektura procesorów – projektowanie procesorów, bez których nie byłoby
 komputerów;
\end_layout

\begin_layout Itemize
bezpieczeństwo komputerowe – dyscyplina łącząca informatykę z telekomunikacją
 w celu zapewnienia poufności i bezpieczeństwa danych;
\end_layout

\begin_layout Itemize
grafika komputerowa – wykorzystuje technikę komputerową w celu wizualizacji
 rzeczywistości;
\end_layout

\begin_layout Itemize
inżynieria oprogramowania – produkcja oprogramowania;
\end_layout

\begin_layout Itemize
języki programowania – tworzenie języków programowania.
 Wyróżniająca się, podstawowa dyscyplina informatyki;
\end_layout

\begin_layout Itemize
programowanie – czyli tworzenie kodu źródłowego programów komputerowych.
 Najpopularniejsza dyscyplina informatyki;
\end_layout

\begin_layout Itemize
sprzęt komputerowy – komputery i ich urządzenia peryferyjne;
\end_layout

\begin_layout Itemize
symulacja komputerowa – komputerowa symulacja z wykorzystaniem modelowania
 matematycznego;
\end_layout

\begin_layout Itemize
systemy informatyczne – tworzenie systemów informatycznych w celach użytkowych;
\end_layout

\begin_layout Itemize
sztuczna inteligencja – komputerowe symulowanie inteligencji;
\end_layout

\begin_layout Itemize
teoria informacji – dyscyplina zajmująca się problematyką informacji, w
 tym teorią przetwarzania i przesyłania informacji;
\end_layout

\begin_layout Itemize
webmastering – projektowanie, programowanie i publikacja serwisów internetowych.
\end_layout

\begin_layout Section
Przedstawić cechy programowania strukturalnego.
 
\end_layout

\begin_layout Section
Scharakteryzować paradygmat programowania obiektowego.
\end_layout

\begin_layout Section*
Abstrakcja
\end_layout

\begin_layout Standard
Każdy obiekt w systemie służy jako model abstrakcyjnego "wykonawcy", który
 może wykonywać pracę, opisywać i zmieniać swój stan oraz komunikować się
 z innymi obiektami w systemie bez ujawniania, w jaki sposób zaimplementowano
 dane cechy.
 Procesy, funkcje lub metody mogą być również abstrahowane, a kiedy tak
 się dzieje, konieczne są rozmaite techniki rozszerzania abstrakcji.
\end_layout

\begin_layout Section*
Hermetyzacja
\end_layout

\begin_layout Standard
Czyli ukrywanie implementacji, enkapsulacja.
 Zapewnia, że obiekt nie może zmieniać stanu wewnętrznego innych obiektów
 w nieoczekiwany sposób.
 Tylko własne metody obiektu są uprawnione do zmiany jego stanu.
 Każdy typ obiektu prezentuje innym obiektom swój interfejs, który określa
 dopuszczalne metody współpracy.
 Pewne języki osłabiają to założenie, dopuszczając pewien poziom bezpośredniego
 (kontrolowanego) dostępu do "wnętrzności" obiektu.
 Ograniczają w ten sposób poziom abstrakcji.
 Przykładowo w niektórych kompilatorach języka C++ istnieje możliwość tymczasowe
go wyłączenia mechanizmu enkapsulacji; otwiera to dostęp do wszystkich pól
 i metod prywatnych, ułatwiając programistom pracę nad pośrednimi etapami
 tworzenia kodu i znajdowaniem błędów.
\end_layout

\begin_layout Section*
Polimorfizm
\end_layout

\begin_layout Standard
Referencje i kolekcje obiektów mogą dotyczyć obiektów różnego typu, a wywołanie
 metody dla referencji spowoduje zachowanie odpowiednie dla pełnego typu
 obiektu wywoływanego.
 Jeśli dzieje się to w czasie działania programu, to nazywa się to późnym
 wiązaniem lub wiązaniem dynamicznym.
 Niektóre języki udostępniają bardziej statyczne (w trakcie kompilacji)
 rozwiązania polimorfizmu – na przykład szablony i przeciążanie operatorów
 w C++.
\end_layout

\begin_layout Section*
Dziedziczenie
\end_layout

\begin_layout Standard
Porządkuje i wspomaga polimorfizm i enkapsulację dzięki umożliwieniu definiowani
a i tworzenia specjalizowanych obiektów na podstawie bardziej ogólnych.
 Dla obiektów specjalizowanych nie trzeba redefiniować całej funkcjonalności,
 lecz tylko tę, której nie ma obiekt ogólniejszy.
 W typowym przypadku powstają grupy obiektów zwane klasami, oraz grupy klas
 zwane drzewami.
 Odzwierciedlają one wspólne cechy obiektów.
\end_layout

\begin_layout Section
Omówić elementy klasy w programie.
 
\end_layout

\begin_layout Section
Scharakteryzować cechy algorytmów, w tym złożoność obliczeniową.
\end_layout

\begin_layout Standard
Algorytm – w matematyce oraz informatyce to skończony, uporządkowany ciąg
 jasno zdefiniowanych czynności, koniecznych do wykonania pewnego zadania.
 
\end_layout

\begin_layout Section*
Cechy algorytmów
\end_layout

\begin_layout Itemize
poprawność --- algorytm daje dobre wyniki,
\end_layout

\begin_layout Itemize
jednoznaczność --- daje takie same wyniki przy takich samych danych,
\end_layout

\begin_layout Itemize
skończoność --- wykonuje się w skończonej ilości kroków,
\end_layout

\begin_layout Itemize
sprawność --- czasowa; szybkość działania i pamięciowa; "zasobożerność"
\end_layout

\begin_layout Section*
Złożoność obliczeniowa
\end_layout

\begin_layout Standard
Ilość zasobów niezbędnych do wykonania algorytmu można rozumieć jako jego
 złożoność.
 W zależności od rozważanego zasobu mówimy o złożoności czasowej czy też
 pamięciowej.
 
\end_layout

\begin_layout Standard
Oczywiście w większości wypadków ilość potrzebnych zasobów będzie się różnić
 w zależności od danych wejściowych z zakresu danego zagadnienia.
 Złożoność algorytmu jest funkcją rozmiaru danych wejściowych.
 
\end_layout

\begin_layout Standard
Kolejnym problemem jest fakt, iż złożoność zwykle nie zależy wyłącznie od
 rozmiaru danych, ale może się znacznie różnić dla danych wejściowych o
 identycznym rozmiarze.
 Dwoma często stosowanymi sposobami podejścia są: rozpatrywanie przypadków
 najgorszych (złożoność pesymistyczna) oraz zastosowanie określonego sposobu
 uśrednienia wszystkich możliwych przypadków (złożoność oczekiwana).
\end_layout

\begin_layout Subsection*
Klasa złożoności
\end_layout

\begin_layout Standard
W teorii obliczeń klasa złożoności to zbiór problemów obliczeniowych o podobnej
 złożoności obliczeniowej.
\end_layout

\begin_layout Standard
Na przykład klasa P to zbiór problemów decyzyjnych, które można rozwiązać
 na maszynie Turinga w czasie wielomianowym, natomiast klasa NP to zbiór
 problemów decyzyjnych, które można rozwiązać na niedeterministycznej maszynie
 Turinga w czasie wielomianowym.
 
\end_layout

\begin_layout Section
Wyjaśnić pojęcie algorytmu i dokonać klasyfikacji algorytmów wg wybranych
 kryteriów.
 
\end_layout

\begin_layout Section
Scharakteryzować język programowania i podać wybrane klasyfikacje języków
\end_layout

\begin_layout Section*
Język programowania
\end_layout

\begin_layout Standard
Podobnie jak języki naturalne, język programowania składa się ze zbiorów
 reguł syntaktycznych oraz semantyki, które opisują, jak należy budować
 poprawne wyrażenia oraz jak komputer ma je rozumieć.
 Język programowania pozwala na precyzyjny zapis algorytmów oraz innych
 zadań, jakie komputer ma wykonać.
\end_layout

\begin_layout Section*
Klasyfikacja pod względem wykorzystanych paradygmatów
\end_layout

\begin_layout Itemize
Programowanie proceduralne --- zaleca dzielenie kodu na procedury, czyli
 fragmenty wykonujące ściśle określone operacje,
\end_layout

\begin_layout Itemize
Programowanie strukturalne --- zaleca hierarchiczne dzielenie kodu na bloki,
 z jednym punktem wejścia i jednym lub wieloma punktami wyjścia.
 Chodzi przede wszystkim o nieużywanie (lub ograniczenie) instrukcji skoku
 (goto),
\end_layout

\begin_layout Itemize
Programowanie funkcyjne --- funkcje należą do wartości podstawowych, a nacisk
 kładzie się na wartościowanie (często rekurencyjnych) funkcji, a nie na
 wykonywanie poleceń,
\end_layout

\begin_layout Itemize
Programowanie imperatywne --- opisuje proces wykonywania jako sekwencję
 instrukcji zmieniających stan programu; programy imperatywne składają się
 z ciągu komend do wykonania przez komputer,
\end_layout

\begin_layout Itemize
Programowanie obiektowe --- programy definiuje się za pomocą obiektów ---
 elementów łączących stan (czyli dane, nazywane najczęściej polami) i zachowanie
 (czyli procedury, tu: metody); obiektowy program komputerowy wyrażony jest
 jako zbiór takich obiektów, komunikujących się pomiędzy sobą w celu wykonywania
 zadań,
\end_layout

\begin_layout Itemize
Programowanie uogólnione (generyczne np.
 C++, Scala) --- pozwala na pisanie kodu programu bez wcześniejszej znajomości
 typów danych, na których kod ten będzie pracował,
\end_layout

\begin_layout Itemize
Programowanie zdarzeniowe --- program jest cały czas bombardowany zdarzeniami
 (events), na które musi odpowiedzieć; przepływ sterowania w programie jest
 całkowicie niemożliwy do przewidzenia z góry
\end_layout

\begin_layout Itemize
Programowanie logiczne (np.
 Prolog) --- odmiana programowania deklaratywnego, w której program podawany
 jest jako pewien zestaw zależności, a obliczenia są dowodem pewnego twierdzenia
 w oparciu o te zależności,
\end_layout

\begin_layout Itemize
Programowanie aspektowe (np.
 AspectJ) --- wspomaga separację zagadnień i rozdzielenie programu na części
 w jak największym stopniu niezwiązane funkcjonalnie; oddziela fizycznie
 kod każdego zagadnienia poprzez umieszczenie ich w oddzielnych aspektach
 i logiczne zdefiniowanie punktów interakcji pomiędzy nimi,
\end_layout

\begin_layout Itemize
Programowanie deklaratywne --- w przeciwieństwie do programów napisanych
 imperatywnie, programista opisuje warunki, jakie musi spełniać końcowe
 rozwiązanie (co chcemy osiągnąć), a nie szczegółową sekwencję kroków, które
 do niego prowadzą (jak to zrobić),
\end_layout

\begin_layout Itemize
Programowanie agentowe --- wyższy od abstrakcji programowania obiektowego;
 polega on na tworzeniu agentów, które muszą być przygotowane na otrzymanie
 błędnych danych od innego agenta, lub nieotrzymanie ich w ogóle, 
\end_layout

\begin_layout Itemize
Programowanie modularne --- zaleca stosowanie nadrzędności modułów w stosunku
 do procedur i bloków tworzących program; moduł grupuje funkcjonalnie związane
 ze sobą dane oraz procedury i jest reprezentacją obiektu jednokrotnie występują
cego w programie
\end_layout

\begin_layout Section
Porównać język Java oraz C++.
 
\end_layout

\begin_layout Section
Scharakteryzować wybrane środowisko programistyczne języka C++.
 
\end_layout

\begin_layout Standard
WTF?
\end_layout

\begin_layout Section
Scharakteryzować wybrane środowisko programistyczne języka Java.
 
\end_layout

\begin_layout Section
Omówić dwa wybrane algorytmy sortowania.
 
\end_layout

\begin_layout Section*
Sortowanie przez scalanie
\end_layout

\begin_layout Standard
Wyróżnić można trzy podstawowe kroki:
\end_layout

\begin_layout Enumerate
Podziel zestaw danych na dwie równe części
\end_layout

\begin_layout Enumerate
Zastosuj sortowanie przez scalanie dla każdej z nich oddzielnie, chyba że
 pozostał już tylko jeden element;
\end_layout

\begin_layout Enumerate
Połącz posortowane podciągi w jeden.
\end_layout

\begin_layout Standard
Dobra implementacja w C jest tylko 20% wolniejsza od quicksort.
\end_layout

\begin_layout Section*
Sortowanie bąbelkowe
\end_layout

\begin_layout Standard
Polega na porównywaniu dwóch kolejnych elementów i zamianie ich kolejności,
 jeżeli zaburza ona porządek, w jakim się sortuje tablicę.
 Sortowanie kończy się, gdy podczas kolejnego przejścia nie dokonano żadnej
 zmiany.
 
\end_layout

\begin_layout Section
Wyjaśnić zasady działania instrukcji warunkowej i instrukcji pętli w wybranym
 języku programowania.
 
\end_layout

\begin_layout Section
Scharakteryzować wybrany język skryptowy.
\end_layout

\begin_layout Section*
Ruby
\end_layout

\begin_layout Standard
Ruby to nowoczesny i dojrzały język programowania.
 Zapożycza wiele elementów z języków programowania takich jak Perl, Smalltalk,
 Eiffel, Ada czy Lisp.
 Łączy w sobie programowanie obiektowe, funkcjonalne oraz imperatywne.
\end_layout

\begin_layout Standard
Został opracowany przez Yukihiro “matz” Matsumoto jako narzędzie dla administrat
orów systemów uniksowych, które miało zastąpić język Perl.
 Jednak dzięki powstaniu frameworku do tworzenia aplikacji internetowych
 Ruby on Rails (RoR) Ruby ogromnie zyskał na popularności.
\end_layout

\begin_layout Section*
Cechy szczególne języka Ruby
\end_layout

\begin_layout Standard
Oto kilka charakterystycznych cech języka Ruby, dzięki którym jest on wygodnym
 i potężnym narzędziem:
\end_layout

\begin_layout Subsection*
Bloki i lambdy
\end_layout

\begin_layout Standard
Bloki i lambdy umożliwiające tak zwane domknięcia pozwalają na zamykanie
 bloku kodu oraz zmiennych z otaczającego kontekstu i przekazywanie ich
 innym obiektom.
 Są to bardzo wygodne i łatwe w użyciu narzędzia do tworzenia wywołań zwrotnych,
 filtrów, bloków iteracji a nawet elementów własnego języka domenowego 
\lang american
(Domain-specific Language
\lang polish

\begin_inset Foot
status open

\begin_layout Plain Layout
http://en.wikipedia.org/wiki/Domain-specific_language
\end_layout

\end_inset

 --- DSL).
 W odróżnieniu od anonimowych funkcji czy klas znanych z innych języków,
 dedykowana składnia i możliwość odwoływania się do zmiennych z otaczającego
 kontekstu umożliwia pisanie w sposób funkcjonalny, niemal w tak elastyczny
 sposób jak w języku Lisp.
 
\end_layout

\begin_layout Subsection*
"Duck typing"
\end_layout

\begin_layout Standard
Ruby nie wymaga od programisty deklarowania typów zmiennych.
 Dzięki temu programista może skupić się na logice programu nie martwiąc
 się o interfejsy, typy, deklaracje i inne elementy kodu potrzebne w statycznie
 typowanych językach programowania.
 W Ruby 
\begin_inset Quotes eld
\end_inset

jak coś kwacze jak kaczka to jest kaczką
\begin_inset Quotes erd
\end_inset

 co oznacza, że wystarczy żeby przekazany obiekt miał potrzebne metody aby
 mógł być wykorzystany w danej roli.
\end_layout

\begin_layout Standard
Wadą takiego rozwiązania jest to, że kompilator nie prowadzi programisty
 za rękę.
 Powoduje to, że programy Ruby wymagają intensywnego automatycznego testowania,
 a zespoły pracujące przy pojedynczym module lub programie nie mogą być
 zbyt duże.
 Osobiście uważam, że w rezultacie uzyskujemy dobrze przetestowany i modułowy
 kod.
\end_layout

\begin_layout Subsection*
Automatyczne odśmiecanie pamięci
\end_layout

\begin_layout Standard
W Ruby programista nie musi się martwić alokacją i zwalnianiem pamięci.
 Implementacje Ruby wykorzystują nowoczesne implementacje 
\lang american
Garbage Collector
\lang polish
 (GC)
\begin_inset Foot
status open

\begin_layout Plain Layout
http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)
\end_layout

\end_inset

 takie jak Mark-and-Seweep.
\end_layout

\begin_layout Subsection*
Wszystko jest obiektem
\end_layout

\begin_layout Standard
Ruby jest językiem w pełni obiektowym.
 Każdy element tego języka reprezentowany jest przez obiekt.
 W wielu językach, liczby i inne typy podstawowe nie są obiektami.
 Ruby podąża za Smalltalkiem udostępniając metody i zmienne instancji wszystkim
 swoim typom.
 To ułatwia korzystanie z języka, ponieważ reguły mające zastosowanie do
 obiektów odnoszą się również do całego języka.
\end_layout

\begin_layout Subsection*
Wszystkie wyrażenia zwracają wartość
\end_layout

\begin_layout Standard
W Ruby każde wyrażenie --- nawet takie jak wyrażenia warunkowe --- zwraca
 wartość.
 W wyniku czego programy napisane w Ruby są bardziej ekspresyjne i treściwe.
\end_layout

\begin_layout Subsection*
Prawda w Ruby
\end_layout

\begin_layout Standard
Wszystko co nie jest wartością 
\emph on
\lang american
nil
\emph default
\lang polish
 lub 
\emph on
\lang american
false
\emph default
\lang polish
 jest prawdą.
 Ta prosta zasada powoduje że pisanie wyrażeń warunkowych staje się proste
 i bardzo intuicyjne.
\end_layout

\begin_layout Subsection*
Wyrażenia logiczne zapożyczone z języka Lisp
\end_layout

\begin_layout Standard
Tak jak w języku Lisp argumenty wyrażeń 
\emph on
or
\emph default
 czy 
\emph on
and
\emph default
 są ewaluowane tylko gdy jest to konieczne do ustalenia wartości logicznej
 danego wyrażenia.
 W następstwie tego za pomocą operatorów logicznych można pisać proste wyrażenia
 warunkowe.
\end_layout

\begin_layout Subsection*
Mixin-y
\end_layout

\begin_layout Standard
W Ruby niemożliwe jest wielokrotne dziedziczenie.
 Jest tak ze względu na to, że wielokrotne dziedziczenie bardzo komplikuje
 język programowania (dobrym przykładem jest język C++).
 W zamian Ruby oferuje dużo prostszy i wygodniejszy mechanizm zwany 
\emph on
mixin
\emph default
.
 Polega to na tym, że do klas bądź pojedynczych obiektów można dołączyć
 wcześniej zdefiniowany zestaw metod.
 Umożliwia to rozszerzanie dowolnych klas i obiektów o zestaw nowych zachowań.
\end_layout

\begin_layout Subsection*

\lang american
Meta programing
\end_layout

\begin_layout Standard
Ruby umożliwia definiowanie klas, obiektów i metod z poziomu samego języka.
 Daje to możliwość programowi na dostosowanie interfejsu klasy na przykład
 do zestawu kolumn obecnych w tabeli bazy danych z którą się komunikuje.
 Ta możliwość jest kluczem do sukcesu 
\lang american
Ruby on Rails
\lang polish
.
 Umożliwia wyeliminowanie potrzeby konfiguracji różnych aspektów programów
 wdrażając mantrę 
\begin_inset Quotes eld
\end_inset

konwencja ponad konfiguracją
\begin_inset Quotes erd
\end_inset

 (ang.
 
\lang american
convention over configuration
\lang polish
).
\end_layout

\begin_layout Section
Omówić system stron WWW.
 
\end_layout

\begin_layout Section
Scharakteryzować zasady instalacji i administrowania serwerami internetowymi.
 
\end_layout

\begin_layout Standard
WTF?
\end_layout

\begin_layout Section
Porównać systemy operacyjne klasy Windows i Unix.
 
\end_layout

\begin_layout Section
Scharakteryzować modele cyklu „życia” systemu informatycznego 
\begin_inset Foot
status open

\begin_layout Plain Layout
http://docs8.chomikuj.pl/196923976,PL,0,0,Cykl-zycia-systemu-informatycznego.doc
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Życie systemu – uporządkowany szereg prac (wzajemnie spójnych etapów) wykonanych
 przy tworzeniu systemu informatycznego.
 Poprzez analogię do życia ludzkiego wyróżnić możemy trzy podstawowe fazy:
\end_layout

\begin_layout Enumerate
Faza narodzin – moment uświadamiania sobie (zgłoszenia) potrzeby istnienia
 systemu; początek fazy wzrostu
\end_layout

\begin_layout Enumerate
Faza wzrostu (eksploatacji) – kolejne działania pozwalające na pełne i skuteczne
 stworzenie, a następnie użytkowanie systemu
\end_layout

\begin_layout Enumerate
Faza śmierci – moment zaprzestania eksploatacji systemu.
\end_layout

\begin_layout Standard
W cyklu życia systemu informatycznego najczęściej jednak wyodrębnia się
 następujące fazy:
\end_layout

\begin_layout Enumerate
Analiza wymagań
\end_layout

\begin_layout Enumerate
Projekt
\end_layout

\begin_layout Enumerate
Implementacja (kodowanie)
\end_layout

\begin_layout Enumerate
Testowanie
\end_layout

\begin_layout Enumerate
Instalacja
\end_layout

\begin_layout Enumerate
Eksploatacja
\end_layout

\begin_layout Enumerate
Wycofanie
\end_layout

\begin_layout Section*
Model kaskadowy
\end_layout

\begin_layout Enumerate
Analiza potrzeb
\end_layout

\begin_layout Enumerate
Specyfikacja systemu
\end_layout

\begin_layout Enumerate
Projektowanie
\end_layout

\begin_layout Enumerate
Programowanie
\end_layout

\begin_layout Enumerate
Testowanie
\end_layout

\begin_layout Enumerate
Integracja
\end_layout

\begin_layout Enumerate
Adaptacja i modyfikacja
\end_layout

\begin_layout Enumerate
Eksploatacja
\end_layout

\begin_layout Enumerate
Dezaktualizacja
\end_layout

\begin_layout Section*
Model Fry’ego
\end_layout

\begin_layout Enumerate
Projektowania – realizowane są
\end_layout

\begin_deeper
\begin_layout Enumerate
Formułowanie i analiza potrzeb
\end_layout

\begin_layout Enumerate
Modelowanie konceptualny (opis modelu danych, modelu procesu danych w systemie)
\end_layout

\begin_layout Enumerate
Projektowanie fizyczne
\end_layout

\end_deeper
\begin_layout Enumerate
Eksploatacja
\end_layout

\begin_deeper
\begin_layout Enumerate
Wdrożenie
\end_layout

\begin_layout Enumerate
Eksploatacja
\end_layout

\begin_layout Enumerate
Kontrola
\end_layout

\begin_layout Enumerate
Modyfikacja i adaptacja.
\end_layout

\end_deeper
\begin_layout Section*
Model z prototypem
\end_layout

\begin_layout Standard
Polega na budowaniu prototypu, który prezentowany jest użytkownikowi celem
 weryfikacji i na tej podstawie modyfikowany.
 Takie podejście ma na celu zredukowanie czasu oczekiwania na konkretne
 rezultaty, zapewnienie szybkiego sprzężenia zwrotnego pomiędzy użytkownikiem
 a projektantem, a także zaangażowanie użytkownika w projektowanie i analizę
 potrzeb.
 
\end_layout

\begin_layout Enumerate
Ogólne określenie potrzeb użytkownika
\end_layout

\begin_layout Enumerate
Konstruowanie prototypu
\end_layout

\begin_layout Enumerate
Użycie i weryfikacja prototypu
\end_layout

\begin_layout Enumerate
Modyfikacja prototypu (w zależności od wcześniejszej oceny klienta po wprowadzen
iu zmian następuje powrót do punktu poprzedniego lub następnego)
\end_layout

\begin_layout Enumerate
Przekształcenie w ostatecznie funkcjonujący system
\end_layout

\begin_layout Enumerate
Eksploatacja i modyfikacja systemu
\end_layout

\begin_layout Standard
W zależności od wyników prezentacji możemy mieć do czynienia z jednym z
 dwóch modeli prototypów: 
\end_layout

\begin_layout Enumerate
Tymczasowy --- prototyp odrzucony; stworzony na potrzeby zrozumienie potrzeb
 klienta; może nigdy nie być przekształcony w ostatecznie funkcjonujący
 system,
\end_layout

\begin_layout Enumerate
Rozwojowy --- prototyp przekształcany w ostatecznie funkcjonujący system.
\end_layout

\begin_layout Section*
Model spiralny
\end_layout

\begin_layout Enumerate
planowania
\end_layout

\begin_layout Enumerate
analizy ryzyka
\end_layout

\begin_layout Enumerate
konstruowania
\end_layout

\begin_layout Enumerate
weryfikacji.
\end_layout

\begin_layout Standard
Pracę rozpoczynamy od wstępnych wymagań i planowania projektu, następnie
 na ich podstawie analizujemy ryzyko i konstruujemy wstępny prototyp, który
 zostaje poddany weryfikacji przez użytkownika.
 W kolejnym cyklu planujemy zmiany i analizujemy ryzyko oparte na reakcji
 użytkownika, po czym tworzymy kolejny prototyp do weryfikacji.
 Po kolejnych kilku przebiegach należy spodziewać się, że system przyjmie
 oczekiwaną postać i zakończymy pracę konstrukcją systemu.
 
\end_layout

\begin_layout Section
Omówić etapy tworzenia systemu informatycznego.
 
\end_layout

\begin_layout Section
Wyjaśnij pojęcia: baza danych, system zarządzania bazami danych oraz integralnoś
ć danych.
 
\end_layout

\begin_layout Section
Język baz danych SQL.
 
\end_layout

\begin_layout Section
Instrukcje definiujące dane w SQL.
\end_layout

\begin_layout Section
Zapytania wybierające SQL.
 
\end_layout

\begin_layout Section
Relacyjne bazy danych.
 
\end_layout

\begin_layout Section
Diagram związków encji.
 
\end_layout

\begin_layout Section
Normalizacja baz danych.
 
\end_layout

\begin_layout Section
Narzędzia typu CASE.
 
\end_layout

\begin_layout Section
Scharakteryzować wielowarstwowy model sieci komputerowej.
 
\end_layout

\begin_layout Section
Przedstawić klasyfikację sieci komputerowych.
 
\end_layout

\begin_layout Section
Omówić podstawowe narzędzia administratora sieci komputerowej.
 
\end_layout

\begin_layout Section
Scharakteryzować politykę bezpieczeństwa w systemach komputerowych.
 
\end_layout

\begin_layout Section
Wyjaśnij terminy: identyfikacja, uwierzytelnienie, autoryzacja, spójność
 danych, ślad kontroli.
 
\end_layout

\begin_layout Section
Scharakteryzować komponenty zintegrowanych programów bezpieczeństwa w systemach
 komputerowych.
 
\end_layout

\begin_layout Section
Podstawowe modele kontroli dostępu do systemów operacyjnych i baz danych.
 
\end_layout

\begin_layout Section
Porównanie kryptografii symetrycznej i asymetrycznej.
 
\end_layout

\begin_layout Section
Scharakteryzować podpis elektroniczny.
 
\end_layout

\begin_layout Section
Charakterystyka protokołów uwierzytelniania.
 
\end_layout

\begin_layout Section
Omówić cechy systemów rozproszonych.
 
\end_layout

\begin_layout Section
Scharakteryzować przykładowe architektury systemów rozproszonych.
 
\end_layout

\begin_layout Section
Porównać technologie CORBA i JAVA RMI.
 
\end_layout

\begin_layout Section
Omówić usługi nazewnicze i role rejestrów w systemach rozproszonych.
\end_layout

\begin_layout Section
Sklasyfikować i omówić języki programowania serwisów Internetowych.
 
\end_layout

\begin_layout Section
Scharakteryzować język PHP.
 
\end_layout

\begin_layout Section
Wymienić i krótko omówić instrukcje sterujące w PHP.
 
\end_layout

\begin_layout Section
Scharakteryzować język JavaScript.
 
\end_layout

\begin_layout Section
Omówić kolejne kroki obsługi technologii AJAX z wykorzystaniem PHP.
 
\end_layout

\begin_layout Section
Wymienić i opisać funkcje i operatory stosowane w SQL/XML.
 
\end_layout

\begin_layout Section
Podać i omówić przykład schematu XML w DTD.
 
\end_layout

\begin_layout Section
Podać i omówić przykład schematu XML w XML Schema.
 
\end_layout

\begin_layout Section
Omówić możliwość przetwarzania dokumentów XML w XQuery.
 
\end_layout

\begin_layout Section
Scharakteryzować obsługę baz danych w PHP.
 
\end_layout

\begin_layout Section
Scharakteryzować obsługę baz danych w Javie.
 
\end_layout

\begin_layout Section
Omówić metody zabezpieczania internetowych baz danych.
 
\end_layout

\begin_layout Section
Scharakteryzować modele danych multimedialnych w systemach internetowych.
\end_layout

\begin_layout Section
Wymienić i omówić kolejne kroki wytwarzania witryn internetowych.
\end_layout

\begin_layout Section
Omówić rolę administratora systemu informatycznego.
\end_layout

\begin_layout Section
Charakterystyka infrastruktur klucza publicznego PKI.
\end_layout

\begin_layout Section
Protokół SSL/TSL i jego zastosowania.
\end_layout

\begin_layout Section
Aktorzy i przebieg ataków typu DDoS.
\end_layout

\begin_layout Section
Bezpieczeństwo transakcji elektronicznych i protokół SET.
\end_layout

\begin_layout Section
Na czym polega bezpieczeństwo usługi znakowania czasem? 
\end_layout

\end_body
\end_document
