#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language polish
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\headheight 1cm
\headsep 1cm
\footskip 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Omówić pojęcie informatyki i jej działy.
 
\end_layout

\begin_layout Standard
Informatyka – dyscyplina nauki zaliczana do nauk ścisłych oraz techniki
 zajmująca się przetwarzaniem informacji, w tym również technologiami przetwarza
nia informacji oraz technologiami wytwarzania systemów przetwarzających
 informację.
 Początkowo stanowiła część matematyki, później rozwinęła się do odrębnej
 dyscypliny – pozostaje jednak nadal w ścisłej relacji z matematyką, która
 dostarcza informatyce podstaw teoretycznych.
 
\end_layout

\begin_layout Standard
Bardziej znane i popularne działy informatyki to przede wszystkim:
\end_layout

\begin_layout Itemize
administracja sieciowa – zarządzanie siecią komputerową;
\end_layout

\begin_layout Itemize
administracja systemem – zarządzanie systemem informatycznym;
\end_layout

\begin_layout Itemize
algorytmika – tworzenie i analizowanie algorytmów.
 Podstawowa, najstarsza dyscyplina informatyki;
\end_layout

\begin_layout Itemize
architektura procesorów – projektowanie procesorów, bez których nie byłoby
 komputerów;
\end_layout

\begin_layout Itemize
bezpieczeństwo komputerowe – dyscyplina łącząca informatykę z telekomunikacją
 w celu zapewnienia poufności i bezpieczeństwa danych;
\end_layout

\begin_layout Itemize
grafika komputerowa – wykorzystuje technikę komputerową w celu wizualizacji
 rzeczywistości;
\end_layout

\begin_layout Itemize
inżynieria oprogramowania – produkcja oprogramowania;
\end_layout

\begin_layout Itemize
języki programowania – tworzenie języków programowania.
 Wyróżniająca się, podstawowa dyscyplina informatyki;
\end_layout

\begin_layout Itemize
programowanie – czyli tworzenie kodu źródłowego programów komputerowych.
 Najpopularniejsza dyscyplina informatyki;
\end_layout

\begin_layout Itemize
sprzęt komputerowy – komputery i ich urządzenia peryferyjne;
\end_layout

\begin_layout Itemize
symulacja komputerowa – komputerowa symulacja z wykorzystaniem modelowania
 matematycznego;
\end_layout

\begin_layout Itemize
systemy informatyczne – tworzenie systemów informatycznych w celach użytkowych;
\end_layout

\begin_layout Itemize
sztuczna inteligencja – komputerowe symulowanie inteligencji;
\end_layout

\begin_layout Itemize
teoria informacji – dyscyplina zajmująca się problematyką informacji, w
 tym teorią przetwarzania i przesyłania informacji;
\end_layout

\begin_layout Itemize
webmastering – projektowanie, programowanie i publikacja serwisów internetowych.
\end_layout

\begin_layout Section
Przedstawić cechy programowania strukturalnego.
 
\end_layout

\begin_layout Section
Scharakteryzować paradygmat programowania obiektowego.
\end_layout

\begin_layout Section*
Abstrakcja
\end_layout

\begin_layout Standard
Każdy obiekt w systemie służy jako model abstrakcyjnego "wykonawcy", który
 może wykonywać pracę, opisywać i zmieniać swój stan oraz komunikować się
 z innymi obiektami w systemie bez ujawniania, w jaki sposób zaimplementowano
 dane cechy.
 Procesy, funkcje lub metody mogą być również abstrahowane, a kiedy tak
 się dzieje, konieczne są rozmaite techniki rozszerzania abstrakcji.
\end_layout

\begin_layout Section*
Hermetyzacja
\end_layout

\begin_layout Standard
Czyli ukrywanie implementacji, enkapsulacja.
 Zapewnia, że obiekt nie może zmieniać stanu wewnętrznego innych obiektów
 w nieoczekiwany sposób.
 Tylko własne metody obiektu są uprawnione do zmiany jego stanu.
 Każdy typ obiektu prezentuje innym obiektom swój interfejs, który określa
 dopuszczalne metody współpracy.
 Pewne języki osłabiają to założenie, dopuszczając pewien poziom bezpośredniego
 (kontrolowanego) dostępu do "wnętrzności" obiektu.
 Ograniczają w ten sposób poziom abstrakcji.
 Przykładowo w niektórych kompilatorach języka C++ istnieje możliwość tymczasowe
go wyłączenia mechanizmu enkapsulacji; otwiera to dostęp do wszystkich pól
 i metod prywatnych, ułatwiając programistom pracę nad pośrednimi etapami
 tworzenia kodu i znajdowaniem błędów.
\end_layout

\begin_layout Section*
Polimorfizm
\end_layout

\begin_layout Standard
Referencje i kolekcje obiektów mogą dotyczyć obiektów różnego typu, a wywołanie
 metody dla referencji spowoduje zachowanie odpowiednie dla pełnego typu
 obiektu wywoływanego.
 Jeśli dzieje się to w czasie działania programu, to nazywa się to późnym
 wiązaniem lub wiązaniem dynamicznym.
 Niektóre języki udostępniają bardziej statyczne (w trakcie kompilacji)
 rozwiązania polimorfizmu – na przykład szablony i przeciążanie operatorów
 w C++.
\end_layout

\begin_layout Section*
Dziedziczenie
\end_layout

\begin_layout Standard
Porządkuje i wspomaga polimorfizm i enkapsulację dzięki umożliwieniu definiowani
a i tworzenia specjalizowanych obiektów na podstawie bardziej ogólnych.
 Dla obiektów specjalizowanych nie trzeba redefiniować całej funkcjonalności,
 lecz tylko tę, której nie ma obiekt ogólniejszy.
 W typowym przypadku powstają grupy obiektów zwane klasami, oraz grupy klas
 zwane drzewami.
 Odzwierciedlają one wspólne cechy obiektów.
\end_layout

\begin_layout Section
Omówić elementy klasy w programie.
 
\end_layout

\begin_layout Section
Scharakteryzować cechy algorytmów, w tym złożoność obliczeniową.
\end_layout

\begin_layout Standard
Algorytm – w matematyce oraz informatyce to skończony, uporządkowany ciąg
 jasno zdefiniowanych czynności, koniecznych do wykonania pewnego zadania.
 
\end_layout

\begin_layout Section*
Cechy algorytmów
\end_layout

\begin_layout Itemize
poprawność --- algorytm daje dobre wyniki,
\end_layout

\begin_layout Itemize
jednoznaczność --- daje takie same wyniki przy takich samych danych,
\end_layout

\begin_layout Itemize
skończoność --- wykonuje się w skończonej ilości kroków,
\end_layout

\begin_layout Itemize
sprawność --- czasowa; szybkość działania i pamięciowa; "zasobożerność"
\end_layout

\begin_layout Section*
Złożoność obliczeniowa
\end_layout

\begin_layout Standard
Ilość zasobów niezbędnych do wykonania algorytmu można rozumieć jako jego
 złożoność.
 W zależności od rozważanego zasobu mówimy o złożoności czasowej czy też
 pamięciowej.
 
\end_layout

\begin_layout Standard
Oczywiście w większości wypadków ilość potrzebnych zasobów będzie się różnić
 w zależności od danych wejściowych z zakresu danego zagadnienia.
 Złożoność algorytmu jest funkcją rozmiaru danych wejściowych.
 
\end_layout

\begin_layout Standard
Kolejnym problemem jest fakt, iż złożoność zwykle nie zależy wyłącznie od
 rozmiaru danych, ale może się znacznie różnić dla danych wejściowych o
 identycznym rozmiarze.
 Dwoma często stosowanymi sposobami podejścia są: rozpatrywanie przypadków
 najgorszych (złożoność pesymistyczna) oraz zastosowanie określonego sposobu
 uśrednienia wszystkich możliwych przypadków (złożoność oczekiwana).
\end_layout

\begin_layout Subsection*
Klasa złożoności
\end_layout

\begin_layout Standard
W teorii obliczeń klasa złożoności to zbiór problemów obliczeniowych o podobnej
 złożoności obliczeniowej.
\end_layout

\begin_layout Standard
Na przykład klasa P to zbiór problemów decyzyjnych, które można rozwiązać
 na maszynie Turinga w czasie wielomianowym, natomiast klasa NP to zbiór
 problemów decyzyjnych, które można rozwiązać na niedeterministycznej maszynie
 Turinga w czasie wielomianowym.
 
\end_layout

\begin_layout Section
Wyjaśnić pojęcie algorytmu i dokonać klasyfikacji algorytmów wg wybranych
 kryteriów.
 
\end_layout

\begin_layout Section
Scharakteryzować język programowania i podać wybrane klasyfikacje języków
\end_layout

\begin_layout Section*
Język programowania
\end_layout

\begin_layout Standard
Podobnie jak języki naturalne, język programowania składa się ze zbiorów
 reguł syntaktycznych oraz semantyki, które opisują, jak należy budować
 poprawne wyrażenia oraz jak komputer ma je rozumieć.
 Język programowania pozwala na precyzyjny zapis algorytmów oraz innych
 zadań, jakie komputer ma wykonać.
\end_layout

\begin_layout Section*
Klasyfikacja pod względem wykorzystanych paradygmatów
\end_layout

\begin_layout Itemize
Programowanie proceduralne --- zaleca dzielenie kodu na procedury, czyli
 fragmenty wykonujące ściśle określone operacje,
\end_layout

\begin_layout Itemize
Programowanie strukturalne --- zaleca hierarchiczne dzielenie kodu na bloki,
 z jednym punktem wejścia i jednym lub wieloma punktami wyjścia.
 Chodzi przede wszystkim o nieużywanie (lub ograniczenie) instrukcji skoku
 (goto),
\end_layout

\begin_layout Itemize
Programowanie funkcyjne --- funkcje należą do wartości podstawowych, a nacisk
 kładzie się na wartościowanie (często rekurencyjnych) funkcji, a nie na
 wykonywanie poleceń,
\end_layout

\begin_layout Itemize
Programowanie imperatywne --- opisuje proces wykonywania jako sekwencję
 instrukcji zmieniających stan programu; programy imperatywne składają się
 z ciągu komend do wykonania przez komputer,
\end_layout

\begin_layout Itemize
Programowanie obiektowe --- programy definiuje się za pomocą obiektów ---
 elementów łączących stan (czyli dane, nazywane najczęściej polami) i zachowanie
 (czyli procedury, tu: metody); obiektowy program komputerowy wyrażony jest
 jako zbiór takich obiektów, komunikujących się pomiędzy sobą w celu wykonywania
 zadań,
\end_layout

\begin_layout Itemize
Programowanie uogólnione (generyczne np.
 C++, Scala) --- pozwala na pisanie kodu programu bez wcześniejszej znajomości
 typów danych, na których kod ten będzie pracował,
\end_layout

\begin_layout Itemize
Programowanie zdarzeniowe --- program jest cały czas bombardowany zdarzeniami
 (events), na które musi odpowiedzieć; przepływ sterowania w programie jest
 całkowicie niemożliwy do przewidzenia z góry
\end_layout

\begin_layout Itemize
Programowanie logiczne (np.
 Prolog) --- odmiana programowania deklaratywnego, w której program podawany
 jest jako pewien zestaw zależności, a obliczenia są dowodem pewnego twierdzenia
 w oparciu o te zależności,
\end_layout

\begin_layout Itemize
Programowanie aspektowe (np.
 AspectJ) --- wspomaga separację zagadnień i rozdzielenie programu na części
 w jak największym stopniu niezwiązane funkcjonalnie; oddziela fizycznie
 kod każdego zagadnienia poprzez umieszczenie ich w oddzielnych aspektach
 i logiczne zdefiniowanie punktów interakcji pomiędzy nimi,
\end_layout

\begin_layout Itemize
Programowanie deklaratywne --- w przeciwieństwie do programów napisanych
 imperatywnie, programista opisuje warunki, jakie musi spełniać końcowe
 rozwiązanie (co chcemy osiągnąć), a nie szczegółową sekwencję kroków, które
 do niego prowadzą (jak to zrobić),
\end_layout

\begin_layout Itemize
Programowanie agentowe --- wyższy od abstrakcji programowania obiektowego;
 polega on na tworzeniu agentów, które muszą być przygotowane na otrzymanie
 błędnych danych od innego agenta, lub nieotrzymanie ich w ogóle, 
\end_layout

\begin_layout Itemize
Programowanie modularne --- zaleca stosowanie nadrzędności modułów w stosunku
 do procedur i bloków tworzących program; moduł grupuje funkcjonalnie związane
 ze sobą dane oraz procedury i jest reprezentacją obiektu jednokrotnie występują
cego w programie
\end_layout

\begin_layout Section
Porównać język Java oraz C++.
 
\end_layout

\begin_layout Section
Scharakteryzować wybrane środowisko programistyczne języka C++.
 
\end_layout

\begin_layout Standard
WTF?
\end_layout

\begin_layout Section
Scharakteryzować wybrane środowisko programistyczne języka Java.
 
\end_layout

\begin_layout Section
Omówić dwa wybrane algorytmy sortowania.
 
\end_layout

\begin_layout Section*
Sortowanie przez scalanie
\end_layout

\begin_layout Standard
Wyróżnić można trzy podstawowe kroki:
\end_layout

\begin_layout Enumerate
Podziel zestaw danych na dwie równe części
\end_layout

\begin_layout Enumerate
Zastosuj sortowanie przez scalanie dla każdej z nich oddzielnie, chyba że
 pozostał już tylko jeden element;
\end_layout

\begin_layout Enumerate
Połącz posortowane podciągi w jeden.
\end_layout

\begin_layout Standard
Dobra implementacja w C jest tylko 20% wolniejsza od quicksort.
\end_layout

\begin_layout Section*
Sortowanie bąbelkowe
\end_layout

\begin_layout Standard
Polega na porównywaniu dwóch kolejnych elementów i zamianie ich kolejności,
 jeżeli zaburza ona porządek, w jakim się sortuje tablicę.
 Sortowanie kończy się, gdy podczas kolejnego przejścia nie dokonano żadnej
 zmiany.
 
\end_layout

\begin_layout Section
Wyjaśnić zasady działania instrukcji warunkowej i instrukcji pętli w wybranym
 języku programowania.
 
\end_layout

\begin_layout Section
Scharakteryzować wybrany język skryptowy.
\end_layout

\begin_layout Section*
Ruby
\end_layout

\begin_layout Standard
Ruby to nowoczesny i dojrzały język programowania.
 Zapożycza wiele elementów z języków programowania takich jak Perl, Smalltalk,
 Eiffel, Ada czy Lisp.
 Łączy w sobie programowanie obiektowe, funkcjonalne oraz imperatywne.
\end_layout

\begin_layout Standard
Został opracowany przez Yukihiro “matz” Matsumoto jako narzędzie dla administrat
orów systemów uniksowych, które miało zastąpić język Perl.
 Jednak dzięki powstaniu frameworku do tworzenia aplikacji internetowych
 Ruby on Rails (RoR) Ruby ogromnie zyskał na popularności.
\end_layout

\begin_layout Section*
Cechy szczególne języka Ruby
\end_layout

\begin_layout Standard
Oto kilka charakterystycznych cech języka Ruby, dzięki którym jest on wygodnym
 i potężnym narzędziem:
\end_layout

\begin_layout Subsection*
Bloki i lambdy
\end_layout

\begin_layout Standard
Bloki i lambdy umożliwiające tak zwane domknięcia pozwalają na zamykanie
 bloku kodu oraz zmiennych z otaczającego kontekstu i przekazywanie ich
 innym obiektom.
 Są to bardzo wygodne i łatwe w użyciu narzędzia do tworzenia wywołań zwrotnych,
 filtrów, bloków iteracji a nawet elementów własnego języka domenowego 
\lang american
(Domain-specific Language
\lang polish

\begin_inset Foot
status open

\begin_layout Plain Layout
http://en.wikipedia.org/wiki/Domain-specific_language
\end_layout

\end_inset

 --- DSL).
 W odróżnieniu od anonimowych funkcji czy klas znanych z innych języków,
 dedykowana składnia i możliwość odwoływania się do zmiennych z otaczającego
 kontekstu umożliwia pisanie w sposób funkcjonalny, niemal w tak elastyczny
 sposób jak w języku Lisp.
 
\end_layout

\begin_layout Subsection*
"Duck typing"
\end_layout

\begin_layout Standard
Ruby nie wymaga od programisty deklarowania typów zmiennych.
 Dzięki temu programista może skupić się na logice programu nie martwiąc
 się o interfejsy, typy, deklaracje i inne elementy kodu potrzebne w statycznie
 typowanych językach programowania.
 W Ruby 
\begin_inset Quotes eld
\end_inset

jak coś kwacze jak kaczka to jest kaczką
\begin_inset Quotes erd
\end_inset

 co oznacza, że wystarczy żeby przekazany obiekt miał potrzebne metody aby
 mógł być wykorzystany w danej roli.
\end_layout

\begin_layout Standard
Wadą takiego rozwiązania jest to, że kompilator nie prowadzi programisty
 za rękę.
 Powoduje to, że programy Ruby wymagają intensywnego automatycznego testowania,
 a zespoły pracujące przy pojedynczym module lub programie nie mogą być
 zbyt duże.
 Osobiście uważam, że w rezultacie uzyskujemy dobrze przetestowany i modułowy
 kod.
\end_layout

\begin_layout Subsection*
Automatyczne odśmiecanie pamięci
\end_layout

\begin_layout Standard
W Ruby programista nie musi się martwić alokacją i zwalnianiem pamięci.
 Implementacje Ruby wykorzystują nowoczesne implementacje 
\lang american
Garbage Collector
\lang polish
 (GC)
\begin_inset Foot
status open

\begin_layout Plain Layout
http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)
\end_layout

\end_inset

 takie jak Mark-and-Seweep.
\end_layout

\begin_layout Subsection*
Wszystko jest obiektem
\end_layout

\begin_layout Standard
Ruby jest językiem w pełni obiektowym.
 Każdy element tego języka reprezentowany jest przez obiekt.
 W wielu językach, liczby i inne typy podstawowe nie są obiektami.
 Ruby podąża za Smalltalkiem udostępniając metody i zmienne instancji wszystkim
 swoim typom.
 To ułatwia korzystanie z języka, ponieważ reguły mające zastosowanie do
 obiektów odnoszą się również do całego języka.
\end_layout

\begin_layout Subsection*
Wszystkie wyrażenia zwracają wartość
\end_layout

\begin_layout Standard
W Ruby każde wyrażenie --- nawet takie jak wyrażenia warunkowe --- zwraca
 wartość.
 W wyniku czego programy napisane w Ruby są bardziej ekspresyjne i treściwe.
\end_layout

\begin_layout Subsection*
Prawda w Ruby
\end_layout

\begin_layout Standard
Wszystko co nie jest wartością 
\emph on
\lang american
nil
\emph default
\lang polish
 lub 
\emph on
\lang american
false
\emph default
\lang polish
 jest prawdą.
 Ta prosta zasada powoduje że pisanie wyrażeń warunkowych staje się proste
 i bardzo intuicyjne.
\end_layout

\begin_layout Subsection*
Wyrażenia logiczne zapożyczone z języka Lisp
\end_layout

\begin_layout Standard
Tak jak w języku Lisp argumenty wyrażeń 
\emph on
or
\emph default
 czy 
\emph on
and
\emph default
 są ewaluowane tylko gdy jest to konieczne do ustalenia wartości logicznej
 danego wyrażenia.
 W następstwie tego za pomocą operatorów logicznych można pisać proste wyrażenia
 warunkowe.
\end_layout

\begin_layout Subsection*
Mixin-y
\end_layout

\begin_layout Standard
W Ruby niemożliwe jest wielokrotne dziedziczenie.
 Jest tak ze względu na to, że wielokrotne dziedziczenie bardzo komplikuje
 język programowania (dobrym przykładem jest język C++).
 W zamian Ruby oferuje dużo prostszy i wygodniejszy mechanizm zwany 
\emph on
mixin
\emph default
.
 Polega to na tym, że do klas bądź pojedynczych obiektów można dołączyć
 wcześniej zdefiniowany zestaw metod.
 Umożliwia to rozszerzanie dowolnych klas i obiektów o zestaw nowych zachowań.
\end_layout

\begin_layout Subsection*

\lang american
Meta programing
\end_layout

\begin_layout Standard
Ruby umożliwia definiowanie klas, obiektów i metod z poziomu samego języka.
 Daje to możliwość programowi na dostosowanie interfejsu klasy na przykład
 do zestawu kolumn obecnych w tabeli bazy danych z którą się komunikuje.
 Ta możliwość jest kluczem do sukcesu 
\lang american
Ruby on Rails
\lang polish
.
 Umożliwia wyeliminowanie potrzeby konfiguracji różnych aspektów programów
 wdrażając mantrę 
\begin_inset Quotes eld
\end_inset

konwencja ponad konfiguracją
\begin_inset Quotes erd
\end_inset

 (ang.
 
\lang american
convention over configuration
\lang polish
).
\end_layout

\begin_layout Section
Omówić system stron WWW.
 
\end_layout

\begin_layout Section
Scharakteryzować zasady instalacji i administrowania serwerami internetowymi.
 
\end_layout

\begin_layout Standard
WTF?
\end_layout

\begin_layout Section
Porównać systemy operacyjne klasy Windows i Unix.
 
\end_layout

\begin_layout Section
Scharakteryzować modele cyklu „życia” systemu informatycznego 
\begin_inset Foot
status open

\begin_layout Plain Layout
http://docs8.chomikuj.pl/196923976,PL,0,0,Cykl-zycia-systemu-informatycznego.doc
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Życie systemu – uporządkowany szereg prac (wzajemnie spójnych etapów) wykonanych
 przy tworzeniu systemu informatycznego.
 Poprzez analogię do życia ludzkiego wyróżnić możemy trzy podstawowe fazy:
\end_layout

\begin_layout Enumerate
Faza narodzin – moment uświadamiania sobie (zgłoszenia) potrzeby istnienia
 systemu; początek fazy wzrostu
\end_layout

\begin_layout Enumerate
Faza wzrostu (eksploatacji) – kolejne działania pozwalające na pełne i skuteczne
 stworzenie, a następnie użytkowanie systemu
\end_layout

\begin_layout Enumerate
Faza śmierci – moment zaprzestania eksploatacji systemu.
\end_layout

\begin_layout Standard
W cyklu życia systemu informatycznego najczęściej jednak wyodrębnia się
 następujące fazy:
\end_layout

\begin_layout Enumerate
Analiza wymagań
\end_layout

\begin_layout Enumerate
Projekt
\end_layout

\begin_layout Enumerate
Implementacja (kodowanie)
\end_layout

\begin_layout Enumerate
Testowanie
\end_layout

\begin_layout Enumerate
Instalacja
\end_layout

\begin_layout Enumerate
Eksploatacja
\end_layout

\begin_layout Enumerate
Wycofanie
\end_layout

\begin_layout Section*
Model kaskadowy
\end_layout

\begin_layout Enumerate
Analiza potrzeb
\end_layout

\begin_layout Enumerate
Specyfikacja systemu
\end_layout

\begin_layout Enumerate
Projektowanie
\end_layout

\begin_layout Enumerate
Programowanie
\end_layout

\begin_layout Enumerate
Testowanie
\end_layout

\begin_layout Enumerate
Integracja
\end_layout

\begin_layout Enumerate
Adaptacja i modyfikacja
\end_layout

\begin_layout Enumerate
Eksploatacja
\end_layout

\begin_layout Enumerate
Dezaktualizacja
\end_layout

\begin_layout Section*
Model Fry’ego
\end_layout

\begin_layout Enumerate
Projektowania – realizowane są
\end_layout

\begin_deeper
\begin_layout Enumerate
Formułowanie i analiza potrzeb
\end_layout

\begin_layout Enumerate
Modelowanie konceptualny (opis modelu danych, modelu procesu danych w systemie)
\end_layout

\begin_layout Enumerate
Projektowanie fizyczne
\end_layout

\end_deeper
\begin_layout Enumerate
Eksploatacja
\end_layout

\begin_deeper
\begin_layout Enumerate
Wdrożenie
\end_layout

\begin_layout Enumerate
Eksploatacja
\end_layout

\begin_layout Enumerate
Kontrola
\end_layout

\begin_layout Enumerate
Modyfikacja i adaptacja.
\end_layout

\end_deeper
\begin_layout Section*
Model z prototypem
\end_layout

\begin_layout Standard
Polega na budowaniu prototypu, który prezentowany jest użytkownikowi celem
 weryfikacji i na tej podstawie modyfikowany.
 Takie podejście ma na celu zredukowanie czasu oczekiwania na konkretne
 rezultaty, zapewnienie szybkiego sprzężenia zwrotnego pomiędzy użytkownikiem
 a projektantem, a także zaangażowanie użytkownika w projektowanie i analizę
 potrzeb.
 
\end_layout

\begin_layout Enumerate
Ogólne określenie potrzeb użytkownika
\end_layout

\begin_layout Enumerate
Konstruowanie prototypu
\end_layout

\begin_layout Enumerate
Użycie i weryfikacja prototypu
\end_layout

\begin_layout Enumerate
Modyfikacja prototypu (w zależności od wcześniejszej oceny klienta po wprowadzen
iu zmian następuje powrót do punktu poprzedniego lub następnego)
\end_layout

\begin_layout Enumerate
Przekształcenie w ostatecznie funkcjonujący system
\end_layout

\begin_layout Enumerate
Eksploatacja i modyfikacja systemu
\end_layout

\begin_layout Standard
W zależności od wyników prezentacji możemy mieć do czynienia z jednym z
 dwóch modeli prototypów: 
\end_layout

\begin_layout Enumerate
Tymczasowy --- prototyp odrzucony; stworzony na potrzeby zrozumienie potrzeb
 klienta; może nigdy nie być przekształcony w ostatecznie funkcjonujący
 system,
\end_layout

\begin_layout Enumerate
Rozwojowy --- prototyp przekształcany w ostatecznie funkcjonujący system.
\end_layout

\begin_layout Section*
Model spiralny
\end_layout

\begin_layout Enumerate
planowania
\end_layout

\begin_layout Enumerate
analizy ryzyka
\end_layout

\begin_layout Enumerate
konstruowania
\end_layout

\begin_layout Enumerate
weryfikacji.
\end_layout

\begin_layout Standard
Pracę rozpoczynamy od wstępnych wymagań i planowania projektu, następnie
 na ich podstawie analizujemy ryzyko i konstruujemy wstępny prototyp, który
 zostaje poddany weryfikacji przez użytkownika.
 W kolejnym cyklu planujemy zmiany i analizujemy ryzyko oparte na reakcji
 użytkownika, po czym tworzymy kolejny prototyp do weryfikacji.
 Po kolejnych kilku przebiegach należy spodziewać się, że system przyjmie
 oczekiwaną postać i zakończymy pracę konstrukcją systemu.
 
\end_layout

\begin_layout Section
Omówić etapy tworzenia systemu informatycznego.
 
\end_layout

\begin_layout Section
Wyjaśnij pojęcia: baza danych, system zarządzania bazami danych oraz integralnoś
ć danych.
\end_layout

\begin_layout Section*
Baza danych
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Baza_danych
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zbiór danych zapisanych zgodnie z określonymi regułami.
 W węższym znaczeniu obejmuje dane cyfrowe gromadzone zgodnie z zasadami
 przyjętymi dla danego programu komputerowego specjalizowanego do gromadzenia
 i przetwarzania tych danych.
\end_layout

\begin_layout Section*
System zarządzania bazą danych
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/System_zarządzania_bazą_danych
\end_layout

\end_inset


\end_layout

\begin_layout Standard
System zarządzania bazą danych, SZBD (ang.
 Database Management System, DBMS) – oprogramowanie bądź system informatyczny
 służący do zarządzania bazą danych.
 System zarządzania bazą danych może być również serwerem bazy danych (SBD)
 lub też może udostępniać bazę danych lokalnie – na określonym komputerze.
 
\end_layout

\begin_layout Section*
Integralność danych
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Integralność_danych
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Funkcja bezpieczeństwa polegająca na tym, że dane nie zostały zmienione,
 dodane lub usunięte w nieautoryzowany sposób.
\end_layout

\begin_layout Standard
W odniesieniu do relacyjnych baz danych integralność definiowana jest jako
 połączenie trzech koncepcji: 
\end_layout

\begin_layout Itemize
dokładność (ang.
 accuracy), 
\end_layout

\begin_layout Itemize
prawdziwość (ang.
 correctness), 
\end_layout

\begin_layout Itemize
oraz aktualność (ang.
 validity).
 
\end_layout

\begin_layout Standard
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Model_relacyjny#Integralno.C5.9B.C4.87
\end_layout

\end_inset

Integralność to ograniczenie nakładane na bazę danych przez model relacyjny.
 Dwie podstawowe reguły integralności to integralność encji (wartość klucza
 głównego nie może być wartością NULL) oraz integralność odwołań (nie mogą
 istnieć niedopasowane wartości klucza obcego).
 
\end_layout

\begin_layout Section
Język baz danych SQL.
 
\end_layout

\begin_layout Section
Instrukcje definiujące dane w SQL
\end_layout

\begin_layout Standard
Dzięki DDL (Data Definition Language) można operować na strukturach, w których
 dane są przechowywane – czyli np.
 dodawać, zmieniać i kasować tabele lub bazy.
 Najważniejsze polecenia tej grupy to:
\end_layout

\begin_layout Itemize
CREATE (np.
 CREATE TABLE, CREATE DATABASE, ...) – utworzenie struktury (bazy, tabeli,
 indeksu itp.),
\end_layout

\begin_layout Itemize
DROP (np.
 DROP TABLE, DROP DATABASE, ...) – usunięcie struktury,
\end_layout

\begin_layout Itemize
ALTER (np.
 ALTER TABLE ADD COLUMN ...) – zmiana struktury (dodanie kolumny do tabeli,
 zmiana typu danych w kolumnie tabeli).
\end_layout

\begin_layout Section
Zapytania wybierające SQL.
 
\end_layout

\begin_layout Section
Relacyjne bazy danych
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Relacyjny_model_danych
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Model relacyjny – model organizacji danych bazujący na matematycznej teorii
 mnogości, w szczególności na pojęciu relacji.
 Na modelu relacyjnym oparta jest relacyjna baza danych (ang.
 Relational Database) – baza danych, w której dane są przedstawione w postaci
 relacyjnej.
 
\end_layout

\begin_layout Standard
W najprostszym ujęciu w modelu relacyjnym dane grupowane są w relacje, które
 reprezentowane są przez tablice.
 Relacje są pewnym zbiorem rekordów o identycznej strukturze wewnętrznie
 powiązanych za pomocą związków zachodzących pomiędzy danymi.
 Relacje zgrupowane są w tzw.
 schematy bazy danych.
 Relacją może być tabela zawierająca dane teleadresowe pracowników, zaś
 schemat może zawierać wszystkie dane dotyczące firmy.
 Takie podejście w porównaniu do innych modeli danych ułatwia wprowadzanie
 zmian, zmniejsza możliwość pomyłek, ale dzieje się to kosztem wydajności.
 
\end_layout

\begin_layout Standard
System zarządzania relacyjną bazą danych (ang.
 Relational Database Management System, RDBMS) – to zestaw programów służących
 do korzystania z bazy danych opartej na modelu relacyjnym.
 Większość wewnętrznych języków RDBMS jest w pewnym stopniu zgodna ze standardem
 języka zapytań SQL.
 Język ten doczekał się już dwóch standardów – SQL92 i SQL99, jednak różnice
 pomiędzy teoretycznie SQL-owymi systemami są zbyt duże, żeby możliwe było
 przeniesienie nawet względnie prostej aplikacji z jednego systemu na drugi.
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/System_zarządzania_relacyjną_bazą_danych
\end_layout

\end_inset


\end_layout

\begin_layout Section
Diagram związków encji.
 
\end_layout

\begin_layout Section
Normalizacja baz danych
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Postać_normalna_(bazy_danych)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Postać normalna – postać relacji w bazie danych, w której nie występuje
 redundancja (nadmiarowość), czyli powtarzanie się tych samych informacji.
 Doprowadzeniu relacji do postaci normalnej służy normalizacja bazy danych.
 
\end_layout

\begin_layout Section*
Pierwsza postać normalna (1NF)
\end_layout

\begin_layout Standard
Relacja jest w pierwszej postaci normalnej, jeśli:
\end_layout

\begin_layout Itemize
opisuje jeden obiekt,
\end_layout

\begin_layout Itemize
wartości atrybutów są elementarne (atomowe, niepodzielne) - każda kolumna
 jest wartością skalarną (atomową), a nie macierzą lub listą czy też czymkolwiek
, co posiada własną strukturę,
\end_layout

\begin_layout Itemize
nie zawiera kolekcji (powtarzających się grup informacji),
\end_layout

\begin_layout Itemize
posiada klucz główny,
\end_layout

\begin_layout Itemize
kolejność wierszy może być dowolna (znaczenie danych nie zależy od kolejności
 wierszy).
\end_layout

\begin_layout Standard
Właściwości, które muszą zaistnieć w 1 formie :
\end_layout

\begin_layout Enumerate
Jest zdefiniowany klucz relacji.
\end_layout

\begin_layout Enumerate
Wszystkie atrybuty niekluczowe są w zależności funkcyjnej od klucza.
\end_layout

\begin_layout Section*
Druga postać normalna (2NF)
\end_layout

\begin_layout Standard
Relacja jest w drugiej postaci normalnej wtedy i tylko wtedy, gdy jest w
 I postaci normalnej i każda kolumna zależy funkcyjnie od całego klucza
 głównego (a nie np.
 od części klucza).
 
\end_layout

\begin_layout Section*
Trzecia postać normalna (3NF)
\end_layout

\begin_layout Standard
Mamy z nią do czynienia wtedy i tylko wtedy, gdy tabela jest w 2NF oraz
 gdy wszystkie pola niebędące polami klucza głównego są od niego zależne
 bezpośrednio.
\end_layout

\begin_layout Section*
Postać normalna Boyce'a-Codda (BCNF lub 3.5NF)
\end_layout

\begin_layout Standard
W tej postaci zależności funkcyjne muszą mieć następującą postać: jeżeli
 X → A i atrybut A nie jest zawarty w X, to X jest kluczem lub zawiera klucz.
 
\end_layout

\begin_layout Section*
Czwarta postać normalna (4NF)
\end_layout

\begin_layout Standard
Relacja jest w czwartej postaci normalnej, jeżeli zbiór atrybutów X określa
 wartościowo Y, to zachodzi jeden z następujących warunków (trywialne zależności
 wielowartościowe)
\end_layout

\begin_layout Itemize
Y jest puste lub zawiera się w X,
\end_layout

\begin_layout Itemize
suma zbiorów X i Y jest pełnym zbiorem atrybutów,
\end_layout

\begin_layout Itemize
X zawiera klucz.
\end_layout

\begin_layout Standard
Ponadto 4PN zachodzi wówczas gdy:
\end_layout

\begin_layout Itemize
spełnione są warunki PNB-C
\end_layout

\begin_layout Itemize
istnieją nietrywialne zależności gdzie Y wynika z X, X i Y są rozdzielne
 oraz X jest kluczem.
\end_layout

\begin_layout Standard
Czwarta i piąta postać normalna są w zasadzie używane wyłącznie przy okazji
 rozważań teoretycznych.
\end_layout

\begin_layout Section
Narzędzia typu CASE.
 
\end_layout

\begin_layout Section
Scharakteryzować wielowarstwowy model sieci komputerowej
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename model_osi_tcpip.tiff
	lyxscale 50
	scale 50
	groupId diagram

\end_inset


\end_layout

\begin_layout Section*
Model TCP/IP
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Model_TCP/IP
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Teoretyczny model warstwowej struktury protokołów komunikacyjnych.
 Model TCP/IP został stworzony w latach 70.
 XX wieku w DARPA, aby pomóc w tworzeniu odpornych na atak sieci komputerowych.
 Potem stał się podstawą struktury Internetu.
 
\end_layout

\begin_layout Standard
Podstawowym założeniem modelu TCP/IP jest podział całego zagadnienia komunikacji
 sieciowej na szereg współpracujących ze sobą warstw (ang.
 layers).
 Każda z nich może być tworzona przez programistów zupełnie niezależnie,
 jeżeli narzucimy pewne protokoły według których wymieniają się one informacjami.
 Założenia modelu TCP/IP są pod względem organizacji warstw zbliżone do
 modelu OSI.
 Jednak liczba warstw jest mniejsza i bardziej odzwierciedla prawdziwą strukturę
 Internetu.
 Model TCP/IP składa się z czterech warstw.
 
\end_layout

\begin_layout Subsection*
Warstwa aplikacji
\end_layout

\begin_layout Standard
Warstwa procesowa czy warstwa aplikacji (ang.
 process layer) to najwyższy poziom, w którym pracują użyteczne dla człowieka
 aplikacje takie jak np.
 serwer WWW czy przeglądarka internetowa.
 Obejmuje ona zestaw gotowych protokołów, które aplikacje wykorzystują do
 przesyłania różnego typu informacji w sieci.
 Wykorzystywane protokoły to m.in.: HTTP, Telnet, FTP, TFTP, SNMP, DNS, SMTP,
 X Windows.
 
\end_layout

\begin_layout Subsection*
Warstwa transportowa
\end_layout

\begin_layout Standard
Warstwa transportowa (ang.
 host-to-host layer) gwarantuje pewność przesyłania danych oraz kieruje
 właściwe informacje do odpowiednich aplikacji.
 Opiera się to na wykorzystaniu portów określonych dla każdego połączenia.
 W jednym komputerze może istnieć wiele aplikacji wymieniających dane z
 tym samym komputerem w sieci i nie nastąpi wymieszanie się przesyłanych
 przez nie danych.
 To właśnie ta warstwa nawiązuje i zrywa połączenia między komputerami oraz
 zapewnia pewność transmisji.
 
\end_layout

\begin_layout Subsection*
Warstwa Internetu
\end_layout

\begin_layout Standard
Warstwa Internetu lub warstwa protokołu internetowego (ang.
 internet protocol layer) to sedno działania Internetu.
 W tej warstwie przetwarzane są datagramy posiadające adresy IP.
 Ustalana jest odpowiednia droga do docelowego komputera w sieci.
 Niektóre urządzenia sieciowe posiadają tę warstwę jako najwyższą.
 Są to routery, które zajmują się kierowaniem ruchu w Internecie, bo znają
 topologię sieci.
 Proces odnajdywania przez routery właściwej drogi określa się jako trasowanie.
 
\end_layout

\begin_layout Subsection*
Warstwa dostępu do sieci
\end_layout

\begin_layout Standard
Warstwa dostępu do sieci lub warstwa fizyczna (ang.
 network access layer) jest najniższą warstwą i to ona zajmuje się przekazywanie
m danych przez fizyczne połączenia między urządzeniami sieciowymi.
 Najczęściej są to karty sieciowe lub modemy.
 Dodatkowo warstwa ta jest czasami wyposażona w protokoły do dynamicznego
 określania adresów IP.
 
\end_layout

\begin_layout Section*
Model OSI
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Model_OSI
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OSI (ang.
 Open System Interconnection) lub Model OSI (pełna nazwa ISO OSI RM, ang.
 ISO OSI Reference Model – model odniesienia łączenia systemów otwartych)
 – standard zdefiniowany przez ISO oraz ITU-T opisujący strukturę komunikacji
 sieciowej.
 
\end_layout

\begin_layout Standard
Model ISO OSI RM jest traktowany jako model odniesienia (wzorzec) dla większości
 rodzin protokołów komunikacyjnych.
 Podstawowym założeniem modelu jest podział systemów sieciowych na 7 warstw
 (ang.
 layers) współpracujących ze sobą w ściśle określony sposób.
 
\end_layout

\begin_layout Subsection*
Warstwa 7: aplikacji
\end_layout

\begin_layout Standard
Warstwa aplikacji jest warstwą najwyższą, zajmuje się specyfikacją interfejsu,
 który wykorzystują aplikacje do przesyłania danych do sieci (poprzez kolejne
 warstwy modelu ISO/OSI).
 W przypadku sieci komputerowych aplikacje są zwykle procesami uruchomionymi
 na odległych hostach.
 Interfejs udostępniający programistom usługi dostarczane przez warstwę
 aplikacji opiera się na obiektach nazywanych gniazdami (ang.
 socket).
 
\end_layout

\begin_layout Subsection*
Warstwa 6: prezentacji
\end_layout

\begin_layout Standard
Podczas ruchu w dół zadaniem warstwy prezentacji jest przetworzenie danych
 od aplikacji do postaci kanonicznej (ang.
 canonical representation) zgodnej ze specyfikacją OSI-RM, dzięki czemu
 niższe warstwy zawsze otrzymują dane w tym samym formacie.
 Kiedy informacje płyną w górę, warstwa prezentacji tłumaczy format otrzymywanyc
h danych na zgodny z wewnętrzną reprezentacją systemu docelowego.
 Wynika to ze zróżnicowania systemów komputerowych, które mogą w różny sposób
 interpretować te same dane.
 Dla przykładu bity w bajcie danych w niektórych procesorach są interpretowane
 w odwrotnej kolejności niż w innych.
 Warstwa ta odpowiada za kodowanie i konwersję danych oraz za kompresję
 / dekompresję; szyfrowanie / deszyfrowanie.
 Warstwa prezentacji obsługuje np.
 MPEG, JPG, GIF itp.
 
\end_layout

\begin_layout Subsection*
Warstwa 5: sesji
\end_layout

\begin_layout Standard
Warstwa sesji otrzymuje od różnych aplikacji dane, które muszą zostać odpowiedni
o zsynchronizowane.
 Synchronizacja występuje między warstwami sesji systemu nadawcy i odbiorcy.
 Warstwa sesji "wie", która aplikacja łączy się z którą, dzięki czemu może
 zapewnić właściwy kierunek przepływu danych – nadzoruje połączenie.
 Wznawia je po przerwaniu.
 
\end_layout

\begin_layout Subsection*
Warstwa 4: transportowa
\end_layout

\begin_layout Standard
Warstwa transportowa segmentuje dane oraz składa je w tzw.
 strumień.
 Warstwa ta zapewnia całościowe połączenie między stacjami: źródłową oraz
 docelową, które obejmuje całą drogę transmisji.
 Następuje tutaj podział danych na części, które są kolejno numerowane i
 wysyłane do docelowej stacji.
 Na poziomie tej warstwy do transmisji danych wykorzystuje się dwa protokoły
 TCP (ang.
 Transmission Control Protocol) oraz UDP (ang.
 User Datagram Protocol).
\end_layout

\begin_layout Subsection*
Warstwa 3: sieciowa
\end_layout

\begin_layout Standard
Warstwa sieciowa jako jedyna dysponuje wiedzą dotyczącą fizycznej topologii
 sieci.
 Rozpoznaje, jakie drogi łączą poszczególne komputery (trasowanie) i decyduje,
 ile informacji należy przesłać jednym z połączeń, a ile innym.
 Jeżeli danych do przesłania jest zbyt wiele, to warstwa sieciowa po prostu
 je ignoruje.
 Nie musi zapewniać pewności transmisji, więc w razie błędu pomija niepoprawne
 pakiety danych.
 Standardowa paczka danych czasami oznaczana jest jako NPDU (ang.
 Network Protocol Data Unit).
 Nie znajdują się w nim żadne użyteczne dla użytkowników aplikacje.
 Jedyne jego zadanie, to zapewnienie sprawnej łączności między bardzo odległymi
 punktami sieci.
 Routery są podstawą budowy rozległych sieci informatycznych takich jak
 Internet, bo potrafią odnaleźć najlepszą drogę do przekazania informacji.
 Warstwa sieciowa podczas ruchu w dół umieszcza dane wewnątrz pakietów zrozumiał
ych dla warstw niższych (kapsułkowanie).
 Jednocześnie warstwa sieci używa czterech procesów (adresowanie, enkapsulacja,
 routing, dekapsulacja).
 Protokoły warstwy sieci to: (IPv4, IPv6, ICMP, NOVELL IPX, APPLE TALK,
 CLNS/DECN et).
 
\end_layout

\begin_layout Subsection*
Warstwa 2: łącza danych
\end_layout

\begin_layout Standard
Warstwa łącza danych jest czasami nazywana warstwą liniową lub kanałową.
 Ma ona nadzorować jakość przekazywanych informacji.
 Nadzór ten dotyczy wyłącznie warstwy niższej.
 Warstwa łącza danych ma możliwość zmiany parametrów pracy warstwy fizycznej,
 tak aby obniżyć liczbę pojawiających się podczas przekazu błędów.
 Zajmuje się pakowaniem danych w ramki i wysyłaniem do warstwy fizycznej.
 Rozpoznaje błędy związane z niedotarciem pakietu oraz uszkodzeniem ramek
 i zajmuje się ich naprawą.
 Podczas ruchu w dół w warstwie łącza danych zachodzi enkapsulacja pakietów
 z warstwy sieciowej tak, aby uzyskać ramki zgodne ze standardem.
 Czasami są one oznaczane jako LPDU (ang.
 data Link Protocol Data Unit).
 
\end_layout

\begin_layout Section
Przedstawić klasyfikację sieci komputerowych.
 
\end_layout

\begin_layout Section
Omówić podstawowe narzędzia administratora sieci komputerowej
\end_layout

\begin_layout Section*
ping
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Ping
\end_layout

\end_inset


\end_layout

\begin_layout Standard
ping — nazwa programu używanego w sieciach komputerowych TCP/IP (takich
 jak Internet) służącego do diagnozowania połączeń sieciowych.
 Pozwala na sprawdzenie czy istnieje połączenie pomiędzy hostami testującym
 i testowanym.
 Umożliwia on zmierzenie liczby zgubionych pakietów oraz opóźnień w ich
 transmisji, zwanych lagami.
 
\end_layout

\begin_layout Section*
traceroute
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Traceroute
\end_layout

\end_inset


\end_layout

\begin_layout Standard
traceroute - program służący do badania trasy pakietów w sieci IP.
 Program traceroute jest szeroko dostępny we wszystkich uniksowych systemach
 operacyjnych; jest także dostępny program mtr, który łączy funkcjonalność
 traceroute z narzędziem ping.
 Istnieje również program tracert o podobnej funkcjonalności, zawarty w
 systemach z rodziny Microsoft Windows.
 
\end_layout

\begin_layout Section*
route
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Route
\end_layout

\end_inset


\end_layout

\begin_layout Standard
route – program narzędziowy w systemach uniksowych oraz Windows, który wyświetla
 i umożliwia zmiany tablicy trasowania pakietów sieciowych.
 
\end_layout

\begin_layout Section*
ip
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Ip_(Linux)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
ip - polecenie do konfiguracji interfejsów sieciowych, tablic tras czy tuneli
 w systemach operacyjnych Linux.
 W pełni wspiera protokoły IPv4 i IPv6, działa też z gniazdami BSD.
 Polecenie wchodzi w skład pakietu Iproute2 - narzędzi do zarządzania siecią
 i kontroli ruchu sieciowego (QoS) w systemach Linux.
 Iproute2 zastępuje starsze narzędzia ifconfig czy route jeszcze zachowane
 w dystrybucjach dla kompatybilności.
 
\end_layout

\begin_layout Section*
iptables
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Iptables
\end_layout

\end_inset


\end_layout

\begin_layout Standard
iptables to program sterujący filtrem pakietów (głównie używanym jako zapora
 sieciowa bądź NAT) opracowany dla systemu operacyjnego Linux.
\end_layout

\begin_layout Standard
Program może być używany jako filtr pakietów, bądź tzw.
 stanowa zapora dla systemów Linux z jądrem począwszy od serii 2.4.x, kontrolujący
 połączenia wchodzące i wychodzące do sieci komputerowej lub stacji roboczej.
\end_layout

\begin_layout Section
Scharakteryzować politykę bezpieczeństwa w systemach komputerowych.
 
\end_layout

\begin_layout Section
Wyjaśnij terminy: identyfikacja, uwierzytelnienie, autoryzacja, spójność
 danych, ślad kontroli
\end_layout

\begin_layout Section*
Identyfikacja
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Uwierzytelnianie
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Podmiot deklaruje swoją tożsamość.
\end_layout

\begin_layout Section*
Uwierzytelnianie
\end_layout

\begin_layout Standard
Strona ufająca stosuje odpowiednią technikę uwierzytelniania (authentication
 mechanism) w celu weryfikacji zadeklarowanej wcześniej tożsamości.
\end_layout

\begin_layout Section*
Autoryzacja
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Autoryzacja_(informatyka)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Potwierdzenie, czy dany podmiot jest uprawniony do uzyskania dostępu do
 żądanego zasobu.
 Na tym etapie autentyczność podmiotu jest już potwierdzona, nie musi on
 jednak być uprawnionym do uzyskania dostępu w żądanym zakresie.
\end_layout

\begin_layout Standard
Celem autoryzacji jest kontrola dostępu (access control), która potwierdza,
 czy dany podmiot jest uprawniony do korzystania z żądanego zasobu.
 Dla określenia uprawnień danego podmiotu konieczne jest najpierw stwierdzenie
 jego tożsamości, dlatego w typowym zastosowaniu autoryzacja następuje dopiero
 po potwierdzeniu tożsamości podmiotu za pomocą identyfikacji i uwierzytelnienia.
 
\end_layout

\begin_layout Section*
Integralność danych
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Integralność_danych
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Funkcja bezpieczeństwa polegająca na tym, że dane nie zostały zmienione,
 dodane lub usunięte w nieautoryzowany sposób.
\end_layout

\begin_layout Standard
W technice informatycznej i telekomunikacyjnej ochrona integralności zapobiega
 przypadkowemu zniekształceniu danych podczas odczytu, zapisu, transmisji
 lub magazynowania.
 Wykorzystuje się tutaj sumy kontrolne i kody korekcyjne takie jak CRC.
 
\end_layout

\begin_layout Standard
W bezpieczeństwie teleinformatycznym ochrona integralności zapobiega celowej
 modyfikacji danych dokonanej z użyciem zaawansowanych technik, mających
 na celu ukrycie faktu dokonania zmiany.
 Wykorzystuje się tutaj techniki kryptograficzne takie jak kody MAC odporne
 na celowe manipulacje.
 W odniesieniu do relacyjnych baz danych integralność definiowana jest jako
 połączenie trzech koncepcji: dokładność (ang.
 accuracy), prawdziwość (ang.
 correctness), oraz aktualność (ang.
 validity).
 
\end_layout

\begin_layout Section*
Ślad kontroli
\end_layout

\begin_layout Standard
???
\end_layout

\begin_layout Section
Scharakteryzować komponenty zintegrowanych programów bezpieczeństwa w systemach
 komputerowych.
 
\end_layout

\begin_layout Section
Podstawowe modele kontroli dostępu do systemów operacyjnych i baz danych.
\end_layout

\begin_layout Paragraph*
DAC
\end_layout

\begin_layout Standard
określa podstawowe metody kontroli dostępu do obiektów w systemie plików.
 Administratorem uprawnień jest sysadmin lub właściciel obiektu (pliku).
 Rozbudowana wersją DAC jest model ACL – list kontroli dostępu.
\end_layout

\begin_layout Paragraph*
MAC
\end_layout

\begin_layout Standard
ochrania i zabezpiecza procesy, dane i urządzenia systemowe przed szkodliwym
 nadużyciem/wykorzystaniem za pomocą tzw.
 etykiet.
 Właściciel obiektu po jego utworzeniu może nie mieć prawa do późniejszego
 np.
 odczytu!
\end_layout

\begin_layout Paragraph*
RBAC
\end_layout

\begin_layout Standard
ogranicza dostęp do zasobów na podstawie roli, jaką użytkownik pełni w systemie.
 Przystosowany do organizacji, w której działa.
 Ukierunkowany na czynności użytkownika.
 Może wykorzystywać DAC, MAC i inne modele.
\end_layout

\begin_layout Paragraph*
przejmij - przekaż
\end_layout

\begin_layout Itemize
Rozszerzenie modelu macierzowego (DAC) – ujmuje kwestie delegacji i przejmowania
 uprawnień.
\end_layout

\begin_layout Itemize
Informacja o uprawnieniach jest pamiętana w postaci grafu, który opisuje
 wszystkie powiązania dot.
 przepływu informacji.
\end_layout

\begin_layout Itemize
Podmiot ma (w tym modelu!) uprawnienia do obiektu albo innego podmiotu.
\end_layout

\begin_deeper
\begin_layout Itemize
Przekaż - podmiot x przekazuje uprawnienie h, jakie ma do z (obiektu lub
 podmiotu), obiektowi lub podmiotowi y pod warunkiem, że x ma uprawnienie
 g do przekazywania uprawnień.
\end_layout

\begin_layout Itemize
Przejmij - podmiot x przekazuje uprawnienie h (pozbywając się uprawnienia
 h do obiektu z), jakie ma do z (obiektu lub podmiotu), obiektowi lub podmiotowi
 y pod warunkiem, że y ma uprawnienie t do przejęcia uprawnień.
\end_layout

\end_deeper
\begin_layout Paragraph*
Wooda
\end_layout

\begin_layout Standard
Skierowany na realizację polityki bezpieczeństwa w środowisku baz danych.
\end_layout

\begin_layout Itemize
poziomy
\end_layout

\begin_deeper
\begin_layout Itemize
Zewnętrzny,
\end_layout

\begin_layout Itemize
Konceptualny,
\end_layout

\begin_layout Itemize
Wewnętrzny.
\end_layout

\end_deeper
\begin_layout Itemize
podmioty to:
\end_layout

\begin_deeper
\begin_layout Itemize
Użytkownicy,
\end_layout

\begin_layout Itemize
administratorzy uprawnień.
\end_layout

\end_deeper
\begin_layout Itemize
obiekty to 
\end_layout

\begin_deeper
\begin_layout Itemize
tablice bazy danych
\end_layout

\begin_layout Itemize
kolumny tablic
\end_layout

\begin_layout Itemize
tablice wirtualne (widoki)
\end_layout

\begin_layout Itemize
ew.
 funkcje.
\end_layout

\end_deeper
\begin_layout Itemize
Dla poziomu zewnętrznego i konceptualnego są definiowane reguły dostępu,
 które muszą być niesprzeczne.
\end_layout

\begin_layout Paragraph*
Jajodhi-Sadhu
\end_layout

\begin_layout Standard
Kontrola dostępu MAC dla baz danych.
\end_layout

\begin_layout Itemize
Do modelu relacyjnego są wprowadzone atrybuty klasyfikacyjne zw.
 etykietami bezpieczeństwa: jawny < poufny < tajny < ściśle tajny
\end_layout

\begin_layout Itemize
Schemat relacyjny wielopoziomowy: Każdy atrybut oprócz wartości ma nadany
 atrybut klasyfikacyjny, a ponadto cała krotka ma również taki atrybut.
\end_layout

\begin_layout Itemize
Polityka bezpieczeństwa to kontrola dostępu do realizacji operacji typu
 dołącz, aktualizuj, usuń na relacjach wielopoziomowych.
\end_layout

\begin_layout Section
Porównanie kryptografii symetrycznej i asymetrycznej.
 
\end_layout

\begin_layout Section
Scharakteryzować podpis elektroniczny
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Podpis_cyfrowy
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Matematyczny sposób potwierdzania autentyczności cyfrowego dokumentu.
 Istnieje wiele schematów podpisów cyfrowych, obecnie jednak najpopularniejszym
 jest schemat podpisu dokumentów cyfrowych w systemach kryptograficznych
 z kluczem publicznym i jednokierunkową funkcją skrótu - w systemie tym
 do oryginalnej wiadomości dołączany jest skrót dokumentu, zaszyfrowany
 prywatnym kluczem nadawcy.
 Potwierdzenie autentyczności wiadomości jest możliwe po odszyfrowaniu skrótu
 kluczem publicznym nadawcy i porównaniu go z wytworzonym skrótem odebranego
 dokumentu.
\end_layout

\begin_layout Section
Charakterystyka protokołów uwierzytelniania.
 
\end_layout

\begin_layout Section
Omówić cechy systemów rozproszonych
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/System_rozproszony
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To zbiór niezależnych urządzeń technicznych połączonych w jedną, spójną
 logicznie całość.
 Zwykle łączonymi urządzeniami są komputery, rzadziej – systemy automatyki.
 Połączenie najczęściej realizowane jest przez sieć komputerową, jednak
 można wykorzystać również inne – prostsze – magistrale komunikacyjne.
 Urządzenia są wyposażone w oprogramowanie umożliwiające współdzielenie
 zasobów systemowych.
 
\end_layout

\begin_layout Enumerate
Dzielenie zasobów (ang.
 resource sharing) – wielu użytkowników systemu może korzystać z danego
 zasobu (np.
 drukarek, plików, usług, itp.).
\end_layout

\begin_layout Enumerate
Otwartość (ang.
 openness) – podatność na rozszerzenia, możliwość rozbudowy systemu zarówno
 pod względem sprzętowym, jak i oprogramowania.
\end_layout

\begin_layout Enumerate
Współbieżność (ang.
 concurrency) – zdolność do przetwarzania wielu zadań jednocześnie.
\end_layout

\begin_layout Enumerate
Skalowalność (ang.
 scalability) – cecha systemu umożliwiająca zachowanie podobnej wydajności
 systemu przy zwiększaniu skali systemu (np.
 liczby procesów, komputerów, itp.).
\end_layout

\begin_layout Enumerate
Tolerowanie awarii (ang.
 fault tolerance) – właściwość systemu umożliwiająca działania systemu mimo
 pojawiania się błędów i (lub) uszkodzeń (np.
 przez utrzymywanie nadmiarowego sprzętu).
\end_layout

\begin_layout Enumerate
Przezroczystość (ang.
 transparency) – właściwość systemu powodująca postrzeganie systemu przez
 użytkownika jako całości, a nie poszczególnych składowych.
\end_layout

\begin_layout Section
Scharakteryzować przykładowe architektury systemów rozproszonych.
 
\end_layout

\begin_layout Section
Porównać technologie CORBA i JAVA RMI.
 
\end_layout

\begin_layout Section
Omówić usługi nazewnicze i role rejestrów w systemach rozproszonych.
\end_layout

\begin_layout Section
Sklasyfikować i omówić języki programowania serwisów Internetowych.
 
\end_layout

\begin_layout Section
Scharakteryzować język PHP.
 
\end_layout

\begin_layout Section
Wymienić i krótko omówić instrukcje sterujące w PHP.
 
\end_layout

\begin_layout Section
Scharakteryzować język JavaScript.
 
\end_layout

\begin_layout Section
Omówić kolejne kroki obsługi technologii AJAX z wykorzystaniem PHP.
 
\end_layout

\begin_layout Section
Wymienić i opisać funkcje i operatory stosowane w SQL/XML.
 
\end_layout

\begin_layout Section
Podać i omówić przykład schematu XML w DTD.
 
\end_layout

\begin_layout Section
Podać i omówić przykład schematu XML w XML Schema.
 
\end_layout

\begin_layout Section
Omówić możliwość przetwarzania dokumentów XML w XQuery.
 
\end_layout

\begin_layout Section
Scharakteryzować obsługę baz danych w PHP.
 
\end_layout

\begin_layout Section
Scharakteryzować obsługę baz danych w Javie.
 
\end_layout

\begin_layout Section
Omówić metody zabezpieczania internetowych baz danych.
 
\end_layout

\begin_layout Section
Scharakteryzować modele danych multimedialnych w systemach internetowych.
\end_layout

\begin_layout Section
Wymienić i omówić kolejne kroki wytwarzania witryn internetowych.
\end_layout

\begin_layout Section
Omówić rolę administratora systemu informatycznego.
\end_layout

\begin_layout Section
Charakterystyka infrastruktur klucza publicznego PKI.
\end_layout

\begin_layout Section
Protokół SSL/TSL i jego zastosowania.
\end_layout

\begin_layout Section
Aktorzy i przebieg ataków typu DDoS.
\end_layout

\begin_layout Section
Bezpieczeństwo transakcji elektronicznych i protokół SET.
\end_layout

\begin_layout Section
Na czym polega bezpieczeństwo usługi znakowania czasem? 
\end_layout

\end_body
\end_document
